import ts from 'typescript';

export interface TypeSchemaConfig {
  zod?: ZodConfig;
  jsonschema?: JSONSchemaConfig;
}

interface SharedConfig {
  /**
   * Path to input files.
   */
  input: string[];

  /**
   * Path to output directory.
   */
  outputDir: string;

  /**
   * Include exports in the output.
   */
  includeExports?: boolean;

  /**
   * JSDoc options.
   */
  jsdoc?: JSDocOptions;

  /**
   * TypeScript options.
   */
  tsconfig?: string | ts.CompilerOptions;
}

export interface ZodConfig extends SharedConfig {
  /**
   * Naming function for schemas.
   */
  naming?: (name: string) => string;

  /**
   * Add a banner for generated files.
   * @default 'Generated by TypeSchema'
   */
  bannerText?: string;
}

export interface JSONSchemaConfig extends SharedConfig {
  /**
   * Id of the schema.
   */
  id?: string;
}

export interface TypeSchemaTree<Types extends string = string> {
  name: string;
  type: Types;
  properties?: TypeSchemaTree<Types>[];
  // Members are used on enums
  members?: EnumMember[];
  // extends
  heritageClauses?: string[];
  annotations?: PrettiedTags[];
  required?: boolean;
  // Type Reference Node
  // When used inside the writer, it includes #/definitions/...
  $ref?: string;
  additionalProperties?: boolean;
  // Array
  items?: Omit<TypeSchemaTree<Types>, 'name'> & {
    $ref?: string;
  };
}

export interface EnumMember {
  name: string;
  value: string | number | undefined;
  annotations: PrettiedTags[];
}

export interface Metadata {
  isOptional?: boolean;
  dependencies: string[];
  tags?: PrettiedTags[];
  heritageClauses?: string[];
  useTags?: boolean;
  sourceFile: ts.SourceFile;
}

export interface PrettiedTags {
  tagName: string;
  comment?: string | ts.NodeArray<ts.JSDocComment>;
}

export interface JSDocOptions {
  /**
   * Filter types by tag.
   */
  include?: string;

  /**
   * Use Tags for validation
   */
  useTags?: boolean;
}

export interface TypeSchemaNodeV1 {
  node: ts.InterfaceDeclaration | ts.TypeAliasDeclaration | ts.EnumDeclaration;
  sourceFile: ts.SourceFile;
}

export interface ZodProperty {
  identifier: string;
  expressions?: ts.Expression[];
}

export type JSONSchemaPrimitiveName =
  | 'string'
  | 'number'
  | 'integer'
  | 'boolean'
  | 'object'
  | 'array'
  | 'null';

export type JSONSchemaPrimitive =
  | string
  | number
  | boolean
  | JSONSchemaObject
  | JSONSchemaArray
  | null;

export interface JSONSchemaObject {
  [key: string]: JSONSchemaPrimitive;
}

export interface JSONSchemaArray extends Array<JSONSchemaPrimitive> {}
export type JSONSchemaDefinition = JSONSchema | boolean;

export interface JSONSchema {
  $id?: string;
  $ref?: string;
  $schema?: string;
  $comment?: string;
  $defs?: {
    [key: string]: JSONSchemaDefinition;
  };
  type?: JSONSchemaPrimitiveName | JSONSchemaPrimitiveName[];
  enum?: JSONSchemaPrimitive[];
  const?: JSONSchemaPrimitive;
  multipleOf?: number;
  maximum?: number;
  exclusiveMaximum?: number;
  minimum?: number;
  exclusiveMinimum?: number;
  maxLength?: number;
  minLength?: number;
  pattern?: string;
  items?: JSONSchemaDefinition | JSONSchemaDefinition[];
  additionalItems?: JSONSchemaDefinition;
  maxItems?: number;
  minItems?: number;
  uniqueItems?: boolean;
  contains?: JSONSchema;
  maxProperties?: number;
  minProperties?: number;
  required?: string[];
  properties?: {
    [key: string]: JSONSchemaDefinition;
  };
  patternProperties?: {
    [key: string]: JSONSchemaDefinition;
  };
  additionalProperties?: JSONSchemaDefinition;
  dependencies?: {
    [key: string]: JSONSchemaDefinition | string[];
  };
  propertyNames?: JSONSchemaDefinition;
  if?: JSONSchemaDefinition;
  then?: JSONSchemaDefinition;
  else?: JSONSchemaDefinition;
  allOf?: JSONSchemaDefinition[];
  anyOf?: JSONSchemaDefinition[];
  oneOf?: JSONSchemaDefinition[];
  not?: JSONSchemaDefinition;
  format?: string;
  contentMediaType?: string;
  contentEncoding?: string;
  definitions?: {
    [key: string]: JSONSchemaDefinition;
  };
  title?: string;
  description?: string;
  default?: JSONSchemaPrimitive;
  readOnly?: boolean;
  writeOnly?: boolean;
  examples?: JSONSchemaPrimitive;
}

export interface TypeSchemaParser {}

declare module 'typescript' {
  interface NodeWithSourceFile<NodeType = ts.Node> {
    node: NodeType;
    sourceFile: ts.SourceFile;
  }
}
